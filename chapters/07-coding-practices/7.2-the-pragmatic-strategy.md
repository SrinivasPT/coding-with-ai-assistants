# **7.2 The Pragmatic Strategy**

Before reaching for complex patterns like Microservices or CQRS, most teams should start with a proven baseline.

### **7.2.1 The Pragmatic Layered Architecture (Within a Module)**

This architecture is the industry standard for most enterprise applications. It applies specifically **within a Module** in a **Modular Monolith**.

For example, a Billing module and an Inventory module each have their own internal layers (UI components, API endpoints, Services, and Repositories). They communicate only through public APIs or Events, but internally they follow this pragmatic structure.

**Core Stack (Enterprise Example):**

* **Frontend:** Angular (SPA)  
* **API:** .NET Core Web API or Java Spring Boot  
* **Database:** SQL Server  
* **ORM:** Entity Framework Core or Hibernate

#### **Layer 1: Presentation Layer (UI)**

* **Technology:** Angular (Components, Templates, Reactive Forms).  
* **Responsibilities:**  
  * **Strict Data Mirroring:** The UI model (TypeScript interfaces) generally matches the API DTO schema. Deviations should be reviewed and approved.  
  * **Visual Logic Only:** Responsible solely for displaying data and capturing input.  
  * **Basic Validation:** Restrict validation to structural checks: Required, MinLength/MaxLength, Regex Patterns (email/phone).  
  * **State Management:** Hold temporary state (loading spinners, form dirty flags) and cached server state.  
* **Principles & Exceptions:**  
  * **Avoid Business Logic:** Logic should primarily reside on the server. *Exception:* Immediate visual feedback calculations (e.g., estimating total cost before submission) are acceptable but must be re-validated on the server.  
  * **Avoid Direct DB Access:** The UI should not access the DB directly.

#### **Layer 2: API Layer (Controllers)**

* **Technology:** ASP.NET Controllers or Spring RestControllers.  
* **Responsibilities:**  
  * **Traffic Control:** Acts as the gateway for the application.  
  * **Deserialization:** Converts HTTP JSON payloads into strong Types/DTOs.  
  * **Structural Validation:** Validates data format (Data Annotations) before passing it further.  
  * **Orchestration Entry:** Hands off valid requests immediately to the **Application Service**.  
  * **Response Mapping:** Returns standard HTTP Status Codes (200, 400, 404, 500).  
* **Principles & Exceptions:**  
  * **Keep Controllers Thin:** Avoid writing business logic here.  
  * **Dependency Injection:** Controllers should primarily inject Application Services. *Exception:* For extremely simple read-only data (e.g., "Get List of Countries"), calling a Repository directly is acceptable to avoid creating a pass-through service.

#### **Layer 3: Application & Domain Logic (The Core)**

This layer is often split to separate "Workflow" from "Rules".

**A. Application Services (Orchestrators)**

* **Responsibilities:**  
  * **Workflow Management:** "Receive Request \-\> Call Domain Service A \-\> Call Domain Service B \-\> Save \-\> Email."  
  * **Security/Auth:** Verifies if the current user is allowed to execute this workflow.  
  * **Cross-Module Orchestration:** Acts as the diplomat. Can interact with other modules, but **only** via their public Application Service interfaces or Integration Events. Never touches another module's Domain or Database directly.  
  * **DTO Mapping:** Maps API DTOs to Domain Entities.

**B. Domain Services & Entities (Business Logic)**

* **Responsibilities:**  
  * **Entities First:** Place business logic inside the Entity class itself whenever possible (e.g., Order.AddItem()).  
  * **Domain Services:** Use these for logic that spans multiple entities or doesn't fit a single entity (e.g., PricingService.CalculateExchangeRate()).  
  * **Invariant Checking:** Ensures entities are never in an invalid state.  
* **Principles & Exceptions:**  
  * **Strict Module Isolation:** Domain logic must remain "introverted" within the current module's Bounded Context. It **cannot** call services or repositories from other modules. If it needs external data, that data must be passed in as a parameter (value object) by the Application Service.  
  * **Avoid Infrastructure Dependencies:** Domain code should ideally be unaware of HTTP or SQL contexts.  
  * **Collapsing Layers:** For simple CRUD (e.g., "Update User Phone Number"), the Application Service may call the Repository directly, skipping the Domain Service.

#### **Layer 4: Infrastructure & Data Access**

* **Technology:** Entity Framework Core / JPA, Repositories, SQL Server, Excel SDKs (OpenXml), REST Clients.  
* **Responsibilities:**  
  * **Persistence Abstraction:** Hides the complexity of SQL from the business layer.  
  * **System Versioning:** Leveraging **SQL Server Temporal Tables** for built-in, audit-proof history of data changes without cluttering the application code.  
  * **External Integrations:** This layer is not limited to databases. It includes:  
    * **File Loaders:** Reading/Writing Excel, CSV, or XML files.  
    * **Connectors:** Interfaces for 3rd-party APIs (e.g., Payment Gateways, CRM Connectors).  
  * **Query Optimization:** Handling efficient data retrieval (projections, eager loading).  
  * **Mapping:** Maps Domain Entities to Database Tables or External Schemas.  
* **Principles & Exceptions:**  
  * **Return Domain Objects:** Repositories and Connectors should generally return Domain Entities, not DTOs or raw XML/JSON.  
  * **No Business Logic:** Avoid putting business rules in the repository or file parsers.

#### **Layer 5: Database (SQL Server)**

* **Responsibilities:**  
  * **Data Persistence:** Reliable storage of state.  
  * **Referential Integrity:** Enforcing Foreign Keys, Unique Constraints, and Check Constraints.  
* **Principles & Exceptions:**  
  * **Lean Database:** Keep logic out of the DB to ensure testability.  
  * **Exception (Stored Procedures):** Stored Procedures are permitted *only* for high-volume batch operations or complex reporting queries where ORM overhead is prohibitive. They must be documented and version-controlled alongside the code.

#### **Reference Implementation (C\# / .NET Style)**

**1\. The API Controller (Thin Traffic Cop)**

\[ApiController\]  
\[Route("api/\[controller\]")\]  
public class UsersController : ControllerBase  
{  
    private readonly IUserAppService \_userAppService; // Application Service

    public UsersController(IUserAppService userAppService)  
    {  
        \_userAppService \= userAppService;  
    }

    \[HttpPost\]  
    public async Task\<IActionResult\> RegisterUser(\[FromBody\] UserRegistrationDto dto)  
    {  
        if (\!ModelState.IsValid) return BadRequest(ModelState); // Structural validation only

        // Delegate entire workflow to Application Service  
        var result \= await \_userAppService.RegisterUserAsync(dto);

        return CreatedAtAction(nameof(GetUser), new { id \= result.Id }, result);  
    }  
}

**2\. The Application Service (The Orchestrator)**

public class UserAppService : IUserAppService  
{  
    private readonly IUserDomainService \_domainService; // Pure Logic  
    private readonly IUserRepository \_repo;            // Data Access  
    private readonly IEmailService \_emailService;      // Infrastructure

    public async Task\<UserDto\> RegisterUserAsync(UserRegistrationDto input)  
    {  
        // 1\. Orchestrate: Check uniqueness (Data Access)  
        var existing \= await \_repo.GetByEmailAsync(input.Email);  
        if (existing \!= null) throw new UserExistsException();

        // 2\. Map DTO \-\> Entity  
        var newUser \= new User { Email \= input.Email };

        // 3\. Call Domain Logic (Business Rule: e.g., generate code, set status)  
        \_domainService.InitializeNewUser(newUser);

        // 4\. Persist  
        await \_repo.AddAsync(newUser);  
        await \_repo.SaveChangesAsync(); // Commit Unit of Work

        // 5\. Side Effects  
        await \_emailService.SendWelcomeEmail(newUser.Email);

        return MapToDto(newUser);  
    }  
}

### **7.2.2 Batch Processing Strategy**

Batch jobs are critical for enterprise systems but often suffer from fragility. Treat them as first-class citizens with specific architectural rules.

* **Rerunnability (Idempotency):**  
  * **Rule:** A batch job must be able to run multiple times on the same data without corrupting the state.  
  * **Implementation:** Check if a record has already been processed before processing it. Use "Upsert" (Update if exists, Insert if new) logic or explicit status checks (e.g., WHERE Status \= 'Pending').  
* **Checkpointing & Resumability:**  
  * **Rule:** Long-running batches must not be "all-or-nothing." If a job processes 1 million records and fails at record 900,000, it should not restart from zero.  
  * **Implementation:** Commit transactions in chunks (e.g., every 1,000 records). Log the "Last Processed ID" to a job control table. When the job restarts, it reads this ID and resumes.  
* **Graceful Shutdown:**  
  * **Rule:** Batches should listen for cancellation tokens. If the server needs to restart for a patch, the batch should finish the current chunk, save its checkpoint, and exit cleanly rather than being killed mid-transaction.

### **7.2.3 Pattern Stacks by Application Type**

If the "Pragmatic Layered Architecture" doesn't fit, select a stack based on your specific application type:

1. **Data-Centric (Analytics/ETL):**  
   * Modular \+ Functional processing modules \+ Async event-driven pipelines.  
2. **Real-Time Dashboard:**  
   * Event-driven \+ CQRS (for read projections) \+ WebSocket subscriptions.  
3. **E-commerce / Transactional:**  
   * DDD (Bounded Contexts) \+ Repository \+ ACID Transactions.  
4. **Small Utility / Script:**  
   * Procedural with concise tests.