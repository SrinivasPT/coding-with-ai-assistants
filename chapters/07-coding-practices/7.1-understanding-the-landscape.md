[Index](../../index.md) | [Previous](../07-coding-practices.md) | [Next](7.2-the-pragmatic-strategy.md)

# 7.1 Understanding the Landscape**

This section summarizes commonly used architectural patterns, when to use them, and provides a framework for making the right choice.

### **7.1.1 Purpose & Quick Decision Flow**

It is easy to get lost in academic theory. Use this decision flow to quickly identify the right starting point for your system.

**Quick Decision Flow:**

1. **Is the product simple or early-stage?** → Use **Procedural / Modular \+ REST** (See "The Pragmatic Layered Architecture").  
2. **Is the domain complex with heavy business rules?** → Consider **DDD** (Domain-Driven Design).  
3. **Is the system high-volume or read-heavy?** → Consider **CQRS** for scaling reads.  
4. **Does the system require audit trails or time-travel?** → Consider **Event Sourcing**.  
5. **Does the UI require rich interactivity?** → Use **MVVM** \+ Client-side State Management.

### **7.1.2 Pattern Reference (What / When / Trade-offs)**

**Procedural Programming**

* **What:** Functions and scripts. Data flows through linear procedures.  
* **When:** Small apps, scripts, data munging tasks, simple serverless functions.  
* **Trade-offs:** Fast to develop; becomes "spaghetti code" in large systems.

**Object-Oriented (OOP)**

* **What:** Classes and objects; encapsulation, polymorphism.  
* **When:** Systems with stateful models and rich behavior (business objects).  
* **Trade-offs:** Good for modeling; can introduce complexity (inheritance hell) if not using Composition over Inheritance.

**Functional Programming**

* **What:** Pure functions, immutable data, and higher-order functions.  
* **When:** Data transformations, reactive systems, concurrency-focused modules.  
* **Trade-offs:** Predictable and testable; can increase cognitive load for stateful logic.

**Domain-Driven Design (DDD)**

* **What:** Modeling software to match a complex business domain using "Ubiquitous Language" and Bounded Contexts.  
* **When:** Enterprise applications with complex business rules and cross-team ownership.  
* **Trade-offs:** High investment; overkill for simple CRUD apps.

**Command Query Responsibility Segregation (CQRS)**

* **What:** Splitting the **Write Model** (Commands) from the **Read Model** (Queries).  
* **When:** High-performance systems where reads vastly outnumber writes, or where reads require complex joins that writes do not.  
* **Trade-offs:** Adds complexity and eventual consistency issues.

**Event-Driven & Event Sourcing**

* **What:** Systems react to events. In Event Sourcing, state is stored as a sequence of events rather than a current snapshot.  
* **When:** Real-time processing, distributed systems, strict audit requirements (finance/healthcare).  
* **Trade-offs:** Excellent decoupling; harder to debug and reason about state at a specific point in time.

**Repository & Data Access Layer (DAL)**

* **What:** Encapsulating data persistence behind an interface.  
* **When:** Almost any application needing testability and decoupled database logic.  
* **Trade-offs:** Helpful abstraction; avoid "Leakage" where the abstraction hides useful DB features (like complex SQL queries).

**MVC / MVVM / State Management**

* **What:** UI patterns separating Data (Model), UI (View), and Logic (Controller/ViewModel).  
* **When:** Web apps (MVC for server-side, MVVM for React/Angular/Vue).  
* **Trade-offs:** Adds boilerplate; crucial for maintainable UI code.

### **7.1.3 Pattern Matrix (Quick Comparison)**

| Pattern | Best For | Complexity | Scales Well For |
| :---- | :---- | :---- | :---- |
| **Procedural** | Scripts, small tools | Low | Small projects |
| **Modular** | Team dev & medium apps | Low-Medium | Modular Monoliths |
| **OOP** | Domain logic, business objects | Medium | Medium-large systems |
| **Functional** | Data pipelines, concurrency | Medium-High | Parallel processing |
| **DDD** | Complex domains | High | Large distributed systems |
| **CQRS** | Read/write scaling | High | High-volume read/write |
| **Event-driven** | Real-time & decoupled systems | High | Distributed microservices |

[Index](../../index.md) | [Previous](../07-coding-practices.md) | [Next](7.2-the-pragmatic-strategy.md)